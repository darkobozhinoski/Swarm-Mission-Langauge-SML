/*
 * generated by Xtext 2.10.0
 */
package be.uantwerpen.ansymo.missionspecification.serializer;

import be.uantwerpen.ansymo.missionspecification.missionSpecification.Absence;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.AfterScope;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.AfterUntilScope;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.AtomicProposition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Attribute;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.BeforeScope;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.BetweenScope;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.BoolLiteral;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.BoundedExistence;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Condition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.CoveredPointsAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.CoveredTasksAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.CurrentPositionAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.CurrentTaskAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.EqualsCondition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Existence;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.FinishedPointsAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.FinishedTasksAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.GlobalScope;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.GreaterThanCondition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.HomeAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.InAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.InitialPositionAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.InstanceDecl;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.InstanceRef;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.IntLiteral;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.LessThanCondition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.MissionSpecification;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.MissionSpecificationPackage;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.MockProposition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.NotCondition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.PerformingActionAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.PointsAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Precedence;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Property;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Proposition;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.RealLiteral;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.ReferenceAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Response;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.RobotsAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.StringLiteral;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.TaskAreaAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.TasksAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.TeamAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.TodoPointsAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.TodoTasksAssociation;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Type;
import be.uantwerpen.ansymo.missionspecification.missionSpecification.Universality;
import be.uantwerpen.ansymo.missionspecification.services.MissionSpecificationGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MissionSpecificationSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MissionSpecificationGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MissionSpecificationPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MissionSpecificationPackage.ABSENCE:
				sequence_Absence(context, (Absence) semanticObject); 
				return; 
			case MissionSpecificationPackage.AFTER_SCOPE:
				sequence_Scope(context, (AfterScope) semanticObject); 
				return; 
			case MissionSpecificationPackage.AFTER_UNTIL_SCOPE:
				sequence_Scope(context, (AfterUntilScope) semanticObject); 
				return; 
			case MissionSpecificationPackage.ATOMIC_PROPOSITION:
				sequence_AtomicProposition(context, (AtomicProposition) semanticObject); 
				return; 
			case MissionSpecificationPackage.ATTRIBUTE:
				sequence_Attribute(context, (Attribute) semanticObject); 
				return; 
			case MissionSpecificationPackage.BEFORE_SCOPE:
				sequence_Scope(context, (BeforeScope) semanticObject); 
				return; 
			case MissionSpecificationPackage.BETWEEN_SCOPE:
				sequence_Scope(context, (BetweenScope) semanticObject); 
				return; 
			case MissionSpecificationPackage.BOOL_LITERAL:
				sequence_BoolLiteral(context, (BoolLiteral) semanticObject); 
				return; 
			case MissionSpecificationPackage.BOUNDED_EXISTENCE:
				sequence_BoundedExistence(context, (BoundedExistence) semanticObject); 
				return; 
			case MissionSpecificationPackage.CONDITION:
				sequence_BooleanExpression(context, (Condition) semanticObject); 
				return; 
			case MissionSpecificationPackage.COVERED_POINTS_ASSOCIATION:
				sequence_Association(context, (CoveredPointsAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.COVERED_TASKS_ASSOCIATION:
				sequence_Association(context, (CoveredTasksAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.CURRENT_POSITION_ASSOCIATION:
				sequence_Association(context, (CurrentPositionAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.CURRENT_TASK_ASSOCIATION:
				sequence_Association(context, (CurrentTaskAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.EQUALS_CONDITION:
				sequence_BinaryExpression(context, (EqualsCondition) semanticObject); 
				return; 
			case MissionSpecificationPackage.EXISTENCE:
				sequence_Existence(context, (Existence) semanticObject); 
				return; 
			case MissionSpecificationPackage.FINISHED_POINTS_ASSOCIATION:
				sequence_Association(context, (FinishedPointsAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.FINISHED_TASKS_ASSOCIATION:
				sequence_Association(context, (FinishedTasksAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.GLOBAL_SCOPE:
				sequence_Scope(context, (GlobalScope) semanticObject); 
				return; 
			case MissionSpecificationPackage.GREATER_THAN_CONDITION:
				sequence_BinaryExpression(context, (GreaterThanCondition) semanticObject); 
				return; 
			case MissionSpecificationPackage.HOME_ASSOCIATION:
				sequence_Association(context, (HomeAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.IN_ASSOCIATION:
				sequence_Association(context, (InAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.INITIAL_POSITION_ASSOCIATION:
				sequence_Association(context, (InitialPositionAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.INSTANCE_DECL:
				sequence_InstanceDecl(context, (InstanceDecl) semanticObject); 
				return; 
			case MissionSpecificationPackage.INSTANCE_REF:
				sequence_InstanceRef(context, (InstanceRef) semanticObject); 
				return; 
			case MissionSpecificationPackage.INT_LITERAL:
				sequence_IntLiteral(context, (IntLiteral) semanticObject); 
				return; 
			case MissionSpecificationPackage.LESS_THAN_CONDITION:
				sequence_BinaryExpression(context, (LessThanCondition) semanticObject); 
				return; 
			case MissionSpecificationPackage.MISSION_SPECIFICATION:
				sequence_MissionSpecification(context, (MissionSpecification) semanticObject); 
				return; 
			case MissionSpecificationPackage.MOCK_PROPOSITION:
				sequence_Proposition(context, (MockProposition) semanticObject); 
				return; 
			case MissionSpecificationPackage.NOT_CONDITION:
				sequence_UnaryExpression(context, (NotCondition) semanticObject); 
				return; 
			case MissionSpecificationPackage.PERFORMING_ACTION_ASSOCIATION:
				sequence_Association(context, (PerformingActionAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.POINTS_ASSOCIATION:
				sequence_Association(context, (PointsAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.PRECEDENCE:
				sequence_Precedence(context, (Precedence) semanticObject); 
				return; 
			case MissionSpecificationPackage.PROPERTY:
				sequence_Property(context, (Property) semanticObject); 
				return; 
			case MissionSpecificationPackage.PROPOSITION:
				sequence_Proposition(context, (Proposition) semanticObject); 
				return; 
			case MissionSpecificationPackage.REAL_LITERAL:
				sequence_RealLiteral(context, (RealLiteral) semanticObject); 
				return; 
			case MissionSpecificationPackage.REFERENCE_ASSOCIATION:
				sequence_Association(context, (ReferenceAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.RESPONSE:
				sequence_Response(context, (Response) semanticObject); 
				return; 
			case MissionSpecificationPackage.ROBOTS_ASSOCIATION:
				sequence_Association(context, (RobotsAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.STRING_LITERAL:
				sequence_StringLiteral(context, (StringLiteral) semanticObject); 
				return; 
			case MissionSpecificationPackage.TASK_AREA_ASSOCIATION:
				sequence_Association(context, (TaskAreaAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.TASKS_ASSOCIATION:
				sequence_Association(context, (TasksAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.TEAM_ASSOCIATION:
				sequence_Association(context, (TeamAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.TODO_POINTS_ASSOCIATION:
				sequence_Association(context, (TodoPointsAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.TODO_TASKS_ASSOCIATION:
				sequence_Association(context, (TodoTasksAssociation) semanticObject); 
				return; 
			case MissionSpecificationPackage.TYPE:
				sequence_Type(context, (Type) semanticObject); 
				return; 
			case MissionSpecificationPackage.UNIVERSALITY:
				sequence_Universality(context, (Universality) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Pattern returns Absence
	 *     Occurence returns Absence
	 *     Absence returns Absence
	 *
	 * Constraint:
	 *     p=Proposition
	 */
	protected void sequence_Absence(ISerializationContext context, Absence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAbsenceAccess().getPPropositionParserRuleCall_6_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Association returns CoveredPointsAssociation
	 *
	 * Constraint:
	 *     {CoveredPointsAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, CoveredPointsAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns CoveredTasksAssociation
	 *
	 * Constraint:
	 *     {CoveredTasksAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, CoveredTasksAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns CurrentPositionAssociation
	 *
	 * Constraint:
	 *     {CurrentPositionAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, CurrentPositionAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns CurrentTaskAssociation
	 *
	 * Constraint:
	 *     {CurrentTaskAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, CurrentTaskAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns FinishedPointsAssociation
	 *
	 * Constraint:
	 *     {FinishedPointsAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, FinishedPointsAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns FinishedTasksAssociation
	 *
	 * Constraint:
	 *     {FinishedTasksAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, FinishedTasksAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns HomeAssociation
	 *
	 * Constraint:
	 *     {HomeAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, HomeAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns InAssociation
	 *
	 * Constraint:
	 *     {InAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, InAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns InitialPositionAssociation
	 *
	 * Constraint:
	 *     {InitialPositionAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, InitialPositionAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns PerformingActionAssociation
	 *
	 * Constraint:
	 *     {PerformingActionAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, PerformingActionAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns PointsAssociation
	 *
	 * Constraint:
	 *     {PointsAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, PointsAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns ReferenceAssociation
	 *
	 * Constraint:
	 *     {ReferenceAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, ReferenceAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns RobotsAssociation
	 *
	 * Constraint:
	 *     {RobotsAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, RobotsAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns TaskAreaAssociation
	 *
	 * Constraint:
	 *     {TaskAreaAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, TaskAreaAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns TasksAssociation
	 *
	 * Constraint:
	 *     {TasksAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, TasksAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns TeamAssociation
	 *
	 * Constraint:
	 *     {TeamAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, TeamAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns TodoPointsAssociation
	 *
	 * Constraint:
	 *     {TodoPointsAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, TodoPointsAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Association returns TodoTasksAssociation
	 *
	 * Constraint:
	 *     {TodoTasksAssociation}
	 */
	protected void sequence_Association(ISerializationContext context, TodoTasksAssociation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AtomicProposition returns AtomicProposition
	 *
	 * Constraint:
	 *     (
	 *         inst=Instance 
	 *         (cond+=BooleanExpression cond+=BooleanExpression*)? 
	 *         (assoc=Association inst2=Instance (cond2+=BooleanExpression cond2+=BooleanExpression*)?)?
	 *     )
	 */
	protected void sequence_AtomicProposition(ISerializationContext context, AtomicProposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attribute returns Attribute
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Attribute(ISerializationContext context, Attribute semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.ATTRIBUTE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.ATTRIBUTE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAttributeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns EqualsCondition
	 *     BinaryExpression returns EqualsCondition
	 *
	 * Constraint:
	 *     (attr=Attribute val=Literal)
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, EqualsCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__ATTR));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryExpressionAccess().getAttrAttributeParserRuleCall_0_1_0(), semanticObject.getAttr());
		feeder.accept(grammarAccess.getBinaryExpressionAccess().getValLiteralParserRuleCall_0_3_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns GreaterThanCondition
	 *     BinaryExpression returns GreaterThanCondition
	 *
	 * Constraint:
	 *     (attr=Attribute val=Literal)
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, GreaterThanCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__ATTR));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryExpressionAccess().getAttrAttributeParserRuleCall_2_1_0(), semanticObject.getAttr());
		feeder.accept(grammarAccess.getBinaryExpressionAccess().getValLiteralParserRuleCall_2_4_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns LessThanCondition
	 *     BinaryExpression returns LessThanCondition
	 *
	 * Constraint:
	 *     (attr=Attribute val=Literal)
	 */
	protected void sequence_BinaryExpression(ISerializationContext context, LessThanCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__ATTR));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BINARY_EXPRESSION__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBinaryExpressionAccess().getAttrAttributeParserRuleCall_1_1_0(), semanticObject.getAttr());
		feeder.accept(grammarAccess.getBinaryExpressionAccess().getValLiteralParserRuleCall_1_4_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns BoolLiteral
	 *     BoolLiteral returns BoolLiteral
	 *
	 * Constraint:
	 *     (value='true' | value='false')
	 */
	protected void sequence_BoolLiteral(ISerializationContext context, BoolLiteral semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns Condition
	 *
	 * Constraint:
	 *     attr=Attribute
	 */
	protected void sequence_BooleanExpression(ISerializationContext context, Condition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.CONDITION__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.CONDITION__ATTR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBooleanExpressionAccess().getAttrAttributeParserRuleCall_2_1_0(), semanticObject.getAttr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns BoundedExistence
	 *     Occurence returns BoundedExistence
	 *     BoundedExistence returns BoundedExistence
	 *
	 * Constraint:
	 *     (p=Proposition n=INT)
	 */
	protected void sequence_BoundedExistence(ISerializationContext context, BoundedExistence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BOUNDED_EXISTENCE__N) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BOUNDED_EXISTENCE__N));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBoundedExistenceAccess().getPPropositionParserRuleCall_0_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getBoundedExistenceAccess().getNINTTerminalRuleCall_4_0(), semanticObject.getN());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Existence
	 *     Occurence returns Existence
	 *     Existence returns Existence
	 *
	 * Constraint:
	 *     p=Proposition
	 */
	protected void sequence_Existence(ISerializationContext context, Existence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistenceAccess().getPPropositionParserRuleCall_0_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns InstanceDecl
	 *     InstanceDecl returns InstanceDecl
	 *
	 * Constraint:
	 *     (type=Type name=ID?)
	 */
	protected void sequence_InstanceDecl(ISerializationContext context, InstanceDecl semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instance returns InstanceRef
	 *     InstanceRef returns InstanceRef
	 *
	 * Constraint:
	 *     ref=[InstanceDecl|ID]
	 */
	protected void sequence_InstanceRef(ISerializationContext context, InstanceRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.INSTANCE_REF__REF) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.INSTANCE_REF__REF));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInstanceRefAccess().getRefInstanceDeclIDTerminalRuleCall_0_1(), semanticObject.getRef());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns IntLiteral
	 *     IntLiteral returns IntLiteral
	 *
	 * Constraint:
	 *     value=SignedInt
	 */
	protected void sequence_IntLiteral(ISerializationContext context, IntLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.INT_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.INT_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIntLiteralAccess().getValueSignedIntParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MissionSpecification returns MissionSpecification
	 *
	 * Constraint:
	 *     properties+=Property+
	 */
	protected void sequence_MissionSpecification(ISerializationContext context, MissionSpecification semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Precedence
	 *     Order returns Precedence
	 *     Precedence returns Precedence
	 *
	 * Constraint:
	 *     (p=Proposition s=Proposition)
	 */
	protected void sequence_Precedence(ISerializationContext context, Precedence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.ORDER__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.ORDER__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrecedenceAccess().getPPropositionParserRuleCall_1_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getPrecedenceAccess().getSPropositionParserRuleCall_12_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Property returns Property
	 *
	 * Constraint:
	 *     (scope=Scope pattern=Pattern)
	 */
	protected void sequence_Property(ISerializationContext context, Property semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PROPERTY__SCOPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PROPERTY__SCOPE));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PROPERTY__PATTERN) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PROPERTY__PATTERN));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPropertyAccess().getScopeScopeParserRuleCall_0_0(), semanticObject.getScope());
		feeder.accept(grammarAccess.getPropertyAccess().getPatternPatternParserRuleCall_2_0(), semanticObject.getPattern());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns MockProposition
	 *
	 * Constraint:
	 *     {MockProposition}
	 */
	protected void sequence_Proposition(ISerializationContext context, MockProposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Proposition returns Proposition
	 *
	 * Constraint:
	 *     (props+=AtomicProposition props+=AtomicProposition*)
	 */
	protected void sequence_Proposition(ISerializationContext context, Proposition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns RealLiteral
	 *     RealLiteral returns RealLiteral
	 *
	 * Constraint:
	 *     value=SignedReal
	 */
	protected void sequence_RealLiteral(ISerializationContext context, RealLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.REAL_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.REAL_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRealLiteralAccess().getValueSignedRealParserRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Response
	 *     Order returns Response
	 *     Response returns Response
	 *
	 * Constraint:
	 *     (p=Proposition s=Proposition)
	 */
	protected void sequence_Response(ISerializationContext context, Response semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.ORDER__S) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.ORDER__S));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getResponseAccess().getPPropositionParserRuleCall_1_0(), semanticObject.getP());
		feeder.accept(grammarAccess.getResponseAccess().getSPropositionParserRuleCall_7_0(), semanticObject.getS());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns AfterScope
	 *
	 * Constraint:
	 *     q=Proposition
	 */
	protected void sequence_Scope(ISerializationContext context, AfterScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.AFTER_SCOPE__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.AFTER_SCOPE__Q));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getQPropositionParserRuleCall_2_2_0(), semanticObject.getQ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns AfterUntilScope
	 *
	 * Constraint:
	 *     (q=Proposition r=Proposition)
	 */
	protected void sequence_Scope(ISerializationContext context, AfterUntilScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.AFTER_UNTIL_SCOPE__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.AFTER_UNTIL_SCOPE__Q));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.AFTER_UNTIL_SCOPE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.AFTER_UNTIL_SCOPE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getQPropositionParserRuleCall_4_2_0(), semanticObject.getQ());
		feeder.accept(grammarAccess.getScopeAccess().getRPropositionParserRuleCall_4_5_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns BeforeScope
	 *
	 * Constraint:
	 *     r=Proposition
	 */
	protected void sequence_Scope(ISerializationContext context, BeforeScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BEFORE_SCOPE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BEFORE_SCOPE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getRPropositionParserRuleCall_1_2_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns BetweenScope
	 *
	 * Constraint:
	 *     (q=Proposition r=Proposition)
	 */
	protected void sequence_Scope(ISerializationContext context, BetweenScope semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BETWEEN_SCOPE__Q) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BETWEEN_SCOPE__Q));
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.BETWEEN_SCOPE__R) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.BETWEEN_SCOPE__R));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getScopeAccess().getQPropositionParserRuleCall_3_2_0(), semanticObject.getQ());
		feeder.accept(grammarAccess.getScopeAccess().getRPropositionParserRuleCall_3_5_0(), semanticObject.getR());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Scope returns GlobalScope
	 *
	 * Constraint:
	 *     {GlobalScope}
	 */
	protected void sequence_Scope(ISerializationContext context, GlobalScope semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Literal returns StringLiteral
	 *     StringLiteral returns StringLiteral
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_StringLiteral(ISerializationContext context, StringLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.STRING_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.STRING_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStringLiteralAccess().getValueSTRINGTerminalRuleCall_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Type
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Type(ISerializationContext context, Type semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.TYPE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.TYPE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     BooleanExpression returns NotCondition
	 *     UnaryExpression returns NotCondition
	 *
	 * Constraint:
	 *     attr=Attribute
	 */
	protected void sequence_UnaryExpression(ISerializationContext context, NotCondition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.NOT_CONDITION__ATTR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.NOT_CONDITION__ATTR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUnaryExpressionAccess().getAttrAttributeParserRuleCall_2_0(), semanticObject.getAttr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Universality
	 *     Occurence returns Universality
	 *     Universality returns Universality
	 *
	 * Constraint:
	 *     p=Proposition
	 */
	protected void sequence_Universality(ISerializationContext context, Universality semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MissionSpecificationPackage.Literals.PATTERN__P));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUniversalityAccess().getPPropositionParserRuleCall_6_0(), semanticObject.getP());
		feeder.finish();
	}
	
	
}
